The error you encountered is because Jest is not configured to handle ES6 modules by default. You need to configure Jest to transform ES6 syntax using Babel. Here's how you can do it step by step:

1. **Install Babel dependencies**:
   ```bash
   npm install --save-dev @babel/preset-env @babel/core @babel/preset-env
   ```

2. **Create a Babel configuration file**:
   Create a file named `.babelrc` in the root of your project with the following content:
   ```json
   {
     "presets": ["@babel/preset-env"]
   }
   ```

3. **Update your Jest configuration**:
   Add a `jest.config.js` file to the root of your project with the following content:
   ```javascript
   module.exports = {
     transform: {
       "^.+\\.js$": "babel-jest"
     },
     moduleFileExtensions: ["js", "json", "jsx", "node"],
     testEnvironment: "node"
   };
   ```

4. **Ensure your package.json scripts include Jest**:
   Make sure you have the following script in your `package.json`:
   ```json
   "scripts": {
     "test": "jest"
   }
   ```

With these steps, Jest should be able to handle ES6 module syntax.

### Example Test Cases

Now, let's create some basic test cases for your `PostData`, `upload`, and `controller` modules.

#### PostData.test.js
```javascript
import { processDocument } from './api/v1/service-now/integrations/PostData';
import fs from 'fs';
import path from 'path';

jest.mock('fs');

describe('processDocument', () => {
  afterEach(() => {
    jest.resetAllMocks();
  });

  test('should process the document and return the new file path', async () => {
    const mockJsonContent = { tagName: 'TagValue' };
    const mockFilePath = 'mock-file-path';
    const mockNewFileName = path.resolve(`./updated_mock-file-path.docx`);
    
    fs.copyFileSync.mockImplementation((src, dest) => dest);
    fs.createReadStream.mockImplementation(() => ({
      pipe: jest.fn().mockReturnThis(),
      on: jest.fn(),
    }));
    fs.unlink.mockImplementation((filePath, callback) => callback());

    const result = await processDocument(mockJsonContent);
    
    expect(result).toBe(mockNewFileName);
    expect(fs.copyFileSync).toHaveBeenCalledTimes(1);
    expect(fs.createReadStream).toHaveBeenCalledTimes(1);
    expect(fs.unlink).toHaveBeenCalledTimes(1);
  });
});
```

#### upload.test.js
```javascript
import { extractContentControlTags } from './api/v1/service-now/integrations/upload';
import fs from 'fs';

jest.mock('fs');

describe('extractContentControlTags', () => {
  afterEach(() => {
    jest.resetAllMocks();
  });

  test('should extract tags from the document', async () => {
    const mockFilePath = 'mock-file-path';
    const mockData = Buffer.from('mock data');
    const mockTags = { tagName: 'TagValue' };

    fs.promises.readFile.mockResolvedValue(mockData);

    // Mock JSZip and xml2js methods here...

    const result = await extractContentControlTags(mockFilePath);
    
    expect(result).toEqual(mockTags);
    expect(fs.promises.readFile).toHaveBeenCalledTimes(1);
    expect(fs.promises.readFile).toHaveBeenCalledWith(mockFilePath);
  });
});
```

#### Controller.test.js
```javascript
import { handleUpdateDocument, handleExtractTags } from './api/v1/service-now/integrations/controller';
import * as PostData from './api/v1/service-now/integrations/PostData';
import * as upload from './api/v1/service-now/integrations/upload';

jest.mock('./api/v1/service-now/integrations/PostData');
jest.mock('./api/v1/service-now/integrations/upload');

describe('handleUpdateDocument', () => {
  let req, res;

  beforeEach(() => {
    req = { body: { tagName: 'TagValue' } };
    res = {
      setHeader: jest.fn(),
      status: jest.fn().mockReturnThis(),
      send: jest.fn(),
      json: jest.fn(),
    };
  });

  afterEach(() => {
    jest.resetAllMocks();
  });

  test('should process document and send response', async () => {
    const mockFilePath = 'mock-file-path';
    PostData.processDocument.mockResolvedValue(mockFilePath);

    await handleUpdateDocument(req, res);

    expect(PostData.processDocument).toHaveBeenCalledTimes(1);
    expect(PostData.processDocument).toHaveBeenCalledWith(req.body);
    expect(res.setHeader).toHaveBeenCalled();
  });
});

describe('handleExtractTags', () => {
  let req, res;

  beforeEach(() => {
    req = { file: { path: 'mock-file-path' } };
    res = {
      status: jest.fn().mockReturnThis(),
      send: jest.fn(),
      json: jest.fn(),
    };
  });

  afterEach(() => {
    jest.resetAllMocks();
  });

  test('should extract tags and send response', async () => {
    const mockTags = { tagName: 'TagValue' };
    upload.extractContentControlTags.mockResolvedValue(mockTags);

    await handleExtractTags(req, res);

    expect(upload.extractContentControlTags).toHaveBeenCalledTimes(1);
    expect(upload.extractContentControlTags).toHaveBeenCalledWith(req.file.path);
    expect(res.json).toHaveBeenCalledWith(mockTags);
  });
});
```

These are basic test cases to ensure the main functionality works. Adjust the mock implementations and assertions according to your actual code and its behavior.

### Explanation of Test Cases

- **PostData.test.js**:
  - Mocks `fs` methods to simulate file operations.
  - Tests the `processDocument` function to ensure it processes the document and returns the correct file path.

- **upload.test.js**:
  - Mocks `fs` methods to simulate reading file content.
  - Tests the `extractContentControlTags` function to ensure it extracts tags correctly from the document.

- **Controller.test.js**:
  - Mocks the methods from `PostData` and `upload` modules.
  - Tests `handleUpdateDocument` and `handleExtractTags` functions to ensure they process requests and send correct responses.

Make sure to adjust the test cases as per the actual functionality and behavior of your methods.
